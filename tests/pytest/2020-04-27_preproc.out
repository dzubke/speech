nohup: ignoring input
============================= test session starts ==============================
platform linux -- Python 3.6.5, pytest-5.4.1, py-1.8.1, pluggy-0.13.1
rootdir: /home/dzubke/awni_speech/speech/tests/pytest
collected 1 item

test_preproc.py F

=================================== FAILURES ===================================
__________________________________ test_main ___________________________________

path = '/home/dzubke/awni_speech/data/background_noise/178826_40107-lq.wav'
sample_rate = 16000, start_time = 9.39201079224981e-05
end_time = 1.4453439201079223

    def audio_with_sox(path, sample_rate, start_time, end_time):
        """
        crop and resample the recording with sox and loads it.
        """
        with NamedTemporaryFile(suffix=".wav") as tar_file:
            tar_filename = tar_file.name
            sox_params = "sox \"{}\" -r {} -c 1 -b 16 -e si {} trim {} ={} >/dev/null 2>&1".format(path, sample_rate,
                                                                                                   tar_filename, start_time,
                                                                                                   end_time)
            os.system(sox_params)
>           noise_data, samp_rate = array_from_wave(tar_filename)

../../speech/utils/noise_injector.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

file_name = '/tmp/tmpzevhfglp.wav'

    def array_from_wave(file_name):
>       audio, samp_rate = soundfile.read(file_name, dtype='int16')

../../speech/utils/wave.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

file = '/tmp/tmpzevhfglp.wav', frames = -1, start = 0, stop = None
dtype = 'int16', always_2d = False, fill_value = None, out = None
samplerate = None, channels = None, format = None, subtype = None, endian = None
closefd = True

    def read(file, frames=-1, start=0, stop=None, dtype='float64', always_2d=False,
             fill_value=None, out=None, samplerate=None, channels=None,
             format=None, subtype=None, endian=None, closefd=True):
        """Provide audio data from a sound file as NumPy array.
    
        By default, the whole file is read from the beginning, but the
        position to start reading can be specified with `start` and the
        number of frames to read can be specified with `frames`.
        Alternatively, a range can be specified with `start` and `stop`.
    
        If there is less data left in the file than requested, the rest of
        the frames are filled with `fill_value`.
        If no `fill_value` is specified, a smaller array is returned.
    
        Parameters
        ----------
        file : str or int or file-like object
            The file to read from.  See :class:`SoundFile` for details.
        frames : int, optional
            The number of frames to read. If `frames` is negative, the whole
            rest of the file is read.  Not allowed if `stop` is given.
        start : int, optional
            Where to start reading.  A negative value counts from the end.
        stop : int, optional
            The index after the last frame to be read.  A negative value
            counts from the end.  Not allowed if `frames` is given.
        dtype : {'float64', 'float32', 'int32', 'int16'}, optional
            Data type of the returned array, by default ``'float64'``.
            Floating point audio data is typically in the range from
            ``-1.0`` to ``1.0``.  Integer data is in the range from
            ``-2**15`` to ``2**15-1`` for ``'int16'`` and from ``-2**31`` to
            ``2**31-1`` for ``'int32'``.
    
            .. note:: Reading int values from a float file will *not*
                scale the data to [-1.0, 1.0). If the file contains
                ``np.array([42.6], dtype='float32')``, you will read
                ``np.array([43], dtype='int32')`` for ``dtype='int32'``.
    
        Returns
        -------
        audiodata : numpy.ndarray or type(out)
            A two-dimensional (frames x channels) NumPy array is returned.
            If the sound file has only one channel, a one-dimensional array
            is returned.  Use ``always_2d=True`` to return a two-dimensional
            array anyway.
    
            If `out` was specified, it is returned.  If `out` has more
            frames than available in the file (or if `frames` is smaller
            than the length of `out`) and no `fill_value` is given, then
            only a part of `out` is overwritten and a view containing all
            valid frames is returned.
        samplerate : int
            The sample rate of the audio file.
    
        Other Parameters
        ----------------
        always_2d : bool, optional
            By default, reading a mono sound file will return a
            one-dimensional array.  With ``always_2d=True``, audio data is
            always returned as a two-dimensional array, even if the audio
            file has only one channel.
        fill_value : float, optional
            If more frames are requested than available in the file, the
            rest of the output is be filled with `fill_value`.  If
            `fill_value` is not specified, a smaller array is returned.
        out : numpy.ndarray or subclass, optional
            If `out` is specified, the data is written into the given array
            instead of creating a new array.  In this case, the arguments
            `dtype` and `always_2d` are silently ignored!  If `frames` is
            not given, it is obtained from the length of `out`.
        samplerate, channels, format, subtype, endian, closefd
            See :class:`SoundFile`.
    
        Examples
        --------
        >>> import soundfile as sf
        >>> data, samplerate = sf.read('stereo_file.wav')
        >>> data
        array([[ 0.71329652,  0.06294799],
               [-0.26450912, -0.38874483],
               ...
               [ 0.67398441, -0.11516333]])
        >>> samplerate
        44100
    
        """
        with SoundFile(file, 'r', samplerate, channels,
>                      subtype, endian, format, closefd) as f:

../../../../miniconda3/envs/awni_env36/lib/python3.6/site-packages/soundfile.py:257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SoundFile('/tmp/tmpzevhfglp.wav', mode='r', samplerate=0, channels=0, format='FILE', subtype='FILE', endian='FILE')
file = '/tmp/tmpzevhfglp.wav', mode = 'r', samplerate = None, channels = None
subtype = None, endian = None, format = None, closefd = True

    def __init__(self, file, mode='r', samplerate=None, channels=None,
                 subtype=None, endian=None, format=None, closefd=True):
        """Open a sound file.
    
        If a file is opened with `mode` ``'r'`` (the default) or
        ``'r+'``, no sample rate, channels or file format need to be
        given because the information is obtained from the file. An
        exception is the ``'RAW'`` data format, which always requires
        these data points.
    
        File formats consist of three case-insensitive strings:
    
        * a *major format* which is by default obtained from the
          extension of the file name (if known) and which can be
          forced with the format argument (e.g. ``format='WAVEX'``).
        * a *subtype*, e.g. ``'PCM_24'``. Most major formats have a
          default subtype which is used if no subtype is specified.
        * an *endian-ness*, which doesn't have to be specified at all in
          most cases.
    
        A :class:`SoundFile` object is a *context manager*, which means
        if used in a "with" statement, :meth:`.close` is automatically
        called when reaching the end of the code block inside the "with"
        statement.
    
        Parameters
        ----------
        file : str or int or file-like object
            The file to open.  This can be a file name, a file
            descriptor or a Python file object (or a similar object with
            the methods ``read()``/``readinto()``, ``write()``,
            ``seek()`` and ``tell()``).
        mode : {'r', 'r+', 'w', 'w+', 'x', 'x+'}, optional
            Open mode.  Has to begin with one of these three characters:
            ``'r'`` for reading, ``'w'`` for writing (truncates `file`)
            or ``'x'`` for writing (raises an error if `file` already
            exists).  Additionally, it may contain ``'+'`` to open
            `file` for both reading and writing.
            The character ``'b'`` for *binary mode* is implied because
            all sound files have to be opened in this mode.
            If `file` is a file descriptor or a file-like object,
            ``'w'`` doesn't truncate and ``'x'`` doesn't raise an error.
        samplerate : int
            The sample rate of the file.  If `mode` contains ``'r'``,
            this is obtained from the file (except for ``'RAW'`` files).
        channels : int
            The number of channels of the file.
            If `mode` contains ``'r'``, this is obtained from the file
            (except for ``'RAW'`` files).
        subtype : str, sometimes optional
            The subtype of the sound file.  If `mode` contains ``'r'``,
            this is obtained from the file (except for ``'RAW'``
            files), if not, the default value depends on the selected
            `format` (see :func:`default_subtype`).
            See :func:`available_subtypes` for all possible subtypes for
            a given `format`.
        endian : {'FILE', 'LITTLE', 'BIG', 'CPU'}, sometimes optional
            The endian-ness of the sound file.  If `mode` contains
            ``'r'``, this is obtained from the file (except for
            ``'RAW'`` files), if not, the default value is ``'FILE'``,
            which is correct in most cases.
        format : str, sometimes optional
            The major format of the sound file.  If `mode` contains
            ``'r'``, this is obtained from the file (except for
            ``'RAW'`` files), if not, the default value is determined
            from the file extension.  See :func:`available_formats` for
            all possible values.
        closefd : bool, optional
            Whether to close the file descriptor on :meth:`.close`. Only
            applicable if the `file` argument is a file descriptor.
    
        Examples
        --------
        >>> from soundfile import SoundFile
    
        Open an existing file for reading:
    
        >>> myfile = SoundFile('existing_file.wav')
        >>> # do something with myfile
        >>> myfile.close()
    
        Create a new sound file for reading and writing using a with
        statement:
    
        >>> with SoundFile('new_file.wav', 'x+', 44100, 2) as myfile:
        >>>     # do something with myfile
        >>>     # ...
        >>>     assert not myfile.closed
        >>>     # myfile.close() is called automatically at the end
        >>> assert myfile.closed
    
        """
        # resolve PathLike objects (see PEP519 for details):
        # can be replaced with _os.fspath(file) for Python >= 3.6
        file = file.__fspath__() if hasattr(file, '__fspath__') else file
        self._name = file
        if mode is None:
            mode = getattr(file, 'mode', None)
        mode_int = _check_mode(mode)
        self._mode = mode
        self._info = _create_info_struct(file, mode, samplerate, channels,
                                         format, subtype, endian)
>       self._file = self._open(file, mode_int, closefd)

../../../../miniconda3/envs/awni_env36/lib/python3.6/site-packages/soundfile.py:627: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SoundFile('/tmp/tmpzevhfglp.wav', mode='r', samplerate=0, channels=0, format='FILE', subtype='FILE', endian='FILE')
file = b'/tmp/tmpzevhfglp.wav', mode_int = 16, closefd = True

    def _open(self, file, mode_int, closefd):
        """Call the appropriate sf_open*() function from libsndfile."""
        if isinstance(file, (_unicode, bytes)):
            if _os.path.isfile(file):
                if 'x' in self.mode:
                    raise OSError("File exists: {0!r}".format(self.name))
                elif set(self.mode).issuperset('w+'):
                    # truncate the file, because SFM_RDWR doesn't:
                    _os.close(_os.open(file, _os.O_WRONLY | _os.O_TRUNC))
            openfunction = _snd.sf_open
            if isinstance(file, _unicode):
                if _sys.platform == 'win32':
                    openfunction = _snd.sf_wchar_open
                else:
                    file = file.encode(_sys.getfilesystemencoding())
            file_ptr = openfunction(file, mode_int, self._info)
        elif isinstance(file, int):
            file_ptr = _snd.sf_open_fd(file, mode_int, self._info, closefd)
        elif _has_virtual_io_attrs(file, mode_int):
            file_ptr = _snd.sf_open_virtual(self._init_virtual_io(file),
                                            mode_int, self._info, _ffi.NULL)
        else:
            raise TypeError("Invalid file: {0!r}".format(self.name))
        _error_check(_snd.sf_error(file_ptr),
>                    "Error opening {0!r}: ".format(self.name))

../../../../miniconda3/envs/awni_env36/lib/python3.6/site-packages/soundfile.py:1182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

err = 2, prefix = "Error opening '/tmp/tmpzevhfglp.wav': "

    def _error_check(err, prefix=""):
        """Pretty-print a numerical error code if there is an error."""
        if err != 0:
            err_str = _snd.sf_error_number(err)
>           raise RuntimeError(prefix + _ffi.string(err_str).decode('utf-8', 'replace'))
E           RuntimeError: Error opening '/tmp/tmpzevhfglp.wav': System error.

../../../../miniconda3/envs/awni_env36/lib/python3.6/site-packages/soundfile.py:1355: RuntimeError

During handling of the above exception, another exception occurred:

    def test_main():
        config_json = "./cv-val_ctc-config.json"
>       run_preprocess(config_json)

test_preproc.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_preproc.py:25: in run_preprocess
    audio_dataset[index]
../../speech/loader.py:233: in __getitem__
    datum["text"])
../../speech/loader.py:115: in preprocess
    audio_data =  inject_noise(audio_data, samp_rate, self.noise_dir, self.logger, self.noise_levels)
../../speech/utils/noise_injector.py:24: in inject_noise
    return inject_noise_sample(data, data_samp_rate, noise_path, noise_level, logger)
../../speech/utils/noise_injector.py:44: in inject_noise_sample
    noise_dst = audio_with_sox(noise_path, sample_rate, noise_start, noise_end)
../../speech/utils/noise_injector.py:69: in audio_with_sox
    return noise_data
../../../../miniconda3/envs/awni_env36/lib/python3.6/tempfile.py:502: in __exit__
    self.close()
../../../../miniconda3/envs/awni_env36/lib/python3.6/tempfile.py:509: in close
    self._closer.close()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileCloser object at 0x7efd70ffe748>
unlink = <built-in function unlink>

    def close(self, unlink=_os.unlink):
        if not self.close_called and self.file is not None:
            self.close_called = True
            try:
                self.file.close()
            finally:
                if self.delete:
>                   unlink(self.name)
E                   FileNotFoundError: [Errno 2] No such file or directory: '/tmp/tmpzevhfglp.wav'

../../../../miniconda3/envs/awni_env36/lib/python3.6/tempfile.py:446: FileNotFoundError
=========================== short test summary info ============================
FAILED test_preproc.py::test_main - FileNotFoundError: [Errno 2] No such file...
======================== 1 failed in 2463.04s (0:41:03) ========================
